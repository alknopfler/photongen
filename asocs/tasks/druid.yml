# Playbook create ASOCS stack.
#
#  - It populate all DVS.
#  - Create required Port-groups on separate DVS, dedicated for all SRIOV.
#  - Take reference OVA , upload as master template.
#  - Re-create two template , each template for CU and DU.
#  - Create new network adapters and maps each to SRIOV.
#  - Serialize back all VM as templates.
#
# In case of issue mbayramo@vmware.com

# First we get all DVS.
- name: Gather all registered dvswitch
  community.vmware.vmware_dvswitch_info:
    hostname: "{{ vc_name }}"
    username: "{{ vc_user }}"
    password: "{{ vc_pass }}"
    validate_certs: False
  delegate_to: localhost
  register: dvswitch_info

# Now we can Upload ova and convert to template.
- name: "Deploy OVF template"
  community.vmware.vmware_deploy_ovf:
    allow_duplicates: False
    validate_certs: False
    hostname: "{{ vc_name }}"
    username: "{{ vc_user }}"
    password: "{{ vc_pass }}"
    datacenter: "{{ dc }}"
    cluster: "{{ cluster_name }}"
    datastore: "{{ datast }}"
    name: druid_centos_template
    power_on: no
    ovf: "{{ centos_ova }}"
  delegate_to: localhost

# Adjust centos template
- name: Adjusting default druid ova vm attributes
  community.vmware.vmware_guest:
    validate_certs: False
    hostname: "{{ vc_name }}"
    username: "{{ vc_user }}"
    password: "{{ vc_pass }}"
    datacenter: "{{ dc }}"
    cluster: "{{ cluster_name }}"
    state: poweredon
    name: druid_centos_template
    convert: thin
    networks:
      - name: "{{ pg_mgmt_name }}"
    #is_template: no
    disk:
    # slot 0 we don't touch
#    - size_gb: 40
#      controller_type: 'paravirtual'
#      controller_number: 0
#      unit_number: 1
    hardware:
      hotadd_cpu: True
      hotremove_cpu: True
      hotadd_memory: True
      version: "{{ druid.hw_ver | default('14') }}"
      memory_mb: "{{ druid.memory_mb | default('8192') }}"
      num_cpus: "{{ druid.num_cpus | default('2') }}"
      num_cpu_cores_per_socket: "{{ druid.num_cpu_cores_per_socket | default('1') }}"
      mem_limit: "{{ druid.mem_limit | default('0') }}"
      mem_reservation: "{{ druid.mem_reservation | default('0') }}"
      cpu_limit: "{{ druid.cpu_limit | default('0') }}"
      cpu_reservation: "{{ druid.cpu_reservation | default('0') }}"
    wait_for_ip_address: true
    wait_for_ip_address_timeout: 800
  delegate_to: localhost
  register: druid_origin

# - set_fact:
#     toolbox_ip: "{{ json_query('druid_origin.hw_eth0.ipaddresses[0]') }}"
    
- name: Add druid to local inventory
  add_host:
    hostname: "druid.cnfdemo.io"
    ansible_ssh_user: "centos"
    ansible_ssh_pass: "centos"
    ansible_become: false
    ansible_host: "{{ druid_origin.instance.hw_eth0.ipaddresses.0 }}"
    groups:
    - "infra"


- name: Configure Toolbox VM
  block:
  - name: Configure Kubernetes repo
    ansible.builtin.yum_repository:
      name: docker
      description: Repository to install kubectl
      baseurl: https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
      gpgkey:
        - https://packages.cloud.google.com/yum/doc/yum-key.gpg
        - https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
      state: present

  - name: Add repo for Powershell
    shell: curl https://packages.microsoft.com/config/rhel/7/prod.repo | tee /etc/yum.repos.d/microsoft.repo

  - name: Install packages on Toolbox VM
    yum:
      name:
        - curl
        - epel-release
        - wget
        - powershell
        - kubectl
      state: present
  - yum:
      name: jq # that's because it is in the epel-release
      state: present

  - name: Install PowerCLI
    shell: |
      pwsh -c "Set-PSRepository -Name "PSGallery" -InstallationPolicy "Trusted"" && \
      pwsh -c "Find-Module "VMware.PowerCLI" | Install-Module -Scope "AllUsers" -AllowClobber"

  - name: Install jp
    shell: "wget https://github.com/jmespath/jp/releases/latest/download/jp-linux-amd64 -O /usr/local/bin/jp  && chmod +x /usr/local/bin/jp"

  - name: Download Tanzu CLI tarball
    get_url:
      url: "{{ tanzu_cli_path }}"
      dest: /tmp/tanzu-cli-bundle-{{ virtualLabComponents.toolbox.tanzuVersion }}.tar
      mode: 0644

  - name: Install Tanzu CLI
    shell: |
      tar xf tanzu-cli-bundle-{{ virtualLabComponents.toolbox.tanzuVersion }}.tar && \
      install cli/core/v{{ virtualLabComponents.toolbox.tanzuVersion }}/tanzu-core-linux_amd64 /usr/local/bin/tanzu && \
      tanzu plugin install --local cli all
    args:
      chdir: /tmp/

  - name: Make config dirs
    file:
      path: "{{ item }}"
      state: directory
      owner: root
      group: root
      mode: 0700
    loop:
      - "/root/.kube"
      - "/root/.kube-tkg"
      - "/root/.tanzu"
      - "/root/.ssh"

  - name: Copy Tanzu CLI config file
    copy:
      src: "{{ lookup('env','PWD') }}/base/files/virtual/02-vms/toolbox/tanzu-cli-config.yaml"
      dest: "/root/.tanzu/config.yaml"
      mode: 0600
      force: true
      owner: root
      group: root

  delegate_to: druid.cnfdemo.io



